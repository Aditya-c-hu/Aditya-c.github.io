<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Reflections</title>
    <style>
        body {
            font-family: 'Product Sans', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #eeeeee;
        }
        h1 {
            text-align: center;
            color: white;
            background-color: #333333;
            padding: 20px;
        }
        h2 {
            color: #ffffff;
        }
        section {
            margin-bottom: 20px;
            padding: 15px;
            background: #333333;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        p {
            margin: 0 0 10px;
            color: #cccccc;
        }
        .button-container {
            text-align: center;
            margin-top: 20px;
        }
        .button-container a {
            display: inline-block;
            padding: 10px 20px;
            text-decoration: none;
            background-color: #333333;
            color: white;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin-bottom: 10px;
        }
        .button-container a:hover {
            background-color: #1a1a1a;
        }
    </style>
</head>
<body>

    <h1>Reflections</h1>

    <section>
        <h2>What are the kinds of problems we see in nature?</h2>
        <p>Nature presents a variety of challenges that require creative solutions. Some problems, like the changing seasons, follow repetitive patterns and are best addressed through iterative methods.</p>
    </section>

    <section>
        <h2>What is space and time efficiency? Why are they important?</h2>
        <p>Space efficiency refers to the amount of memory a program uses, while time efficiency measures how quickly it runs. Both are essential because resources like memory and time are limited and valuable.</p>
    </section>

    <section>
        <h2>Takeaway from different design principles from Chapter 2</h2>
        <p>Chapter 2 emphasized the importance of breaking down problems and solving them systematically. Modular design involves dividing problems into smaller parts, making them easier to tackle.</p>
    </section>

    <section>
        <h2>The hierarchical data and how different tree data structures solve problems</h2>
        <p>Hierarchical data is prevalent in file systems, organization charts, and game levels. Trees are ideal for managing this type of data. Binary search trees are excellent for quick searching and inserting operations.</p>
    </section>

    <section>
        <h2>The need for array query algorithms and their implications</h2>
        <p>Handling large datasets efficiently requires array query algorithms. For instance, segment trees facilitate range-based queries like summing numbers in a range or finding a maximum. Fenwick trees are useful for cumulative frequency tables.</p>
    </section>

    <section>
        <h2>Differentiate between trees and graphs and their traversals</h2>
        <p>Trees and graphs both deal with nodes and connections, but they’re used for different purposes. Trees are like organized family trees—everything follows a hierarchy, and there's one path between nodes. Graphs can have multiple connections between nodes and can form cycles.</p>
    </section>

    <section>
        <h2>Deliberate on sorting and searching algorithms</h2>
        <p>Sorting and searching are the backbone of efficient data handling. Sorting makes things easier to find or use later, like alphabetizing a list of contacts. Algorithms like quicksort and mergesort are efficient for large datasets.</p>
    </section>

    <section>
        <h2>The importance of graph algorithms</h2>
        <p>Graph algorithms are essential for solving real-world problems, like finding the shortest route on Google Maps. They optimize connections in transportation, communication, or social networks.</p>
    </section>

    <section>
        <h2>Different studied algorithm design techniques</h2>
        <p>The different design techniques we learned—like greedy algorithms, dynamic programming, and divide-and-conquer—all stood out for how systematic they are. Greedy algorithms are like making the most profitable trade at each step, while dynamic programming saves intermediate results to avoid redundant calculations.</p>
    </section>

</body>
</html>
